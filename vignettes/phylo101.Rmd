---
title: "phylo101 Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{phylo101 Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# phylo101: Introduction to Phylogenetics

## Load required packages

```{r setup}
library(adegenet)
library(ape)
library(ggtree)
library(ggimage)
library(readr)
library(phylo101)
```

## Check that metadata is loaded

```{r}
d <- USFluMetadata
print(d)
```

## Check that sequences are loaded

```{r}
s <- USFluSeqs
print(s)
```

# Models of DNA Evolution

## Calculate pairwise distances

Wikipedia entry about models: <https://en.wikipedia.org/wiki/Models_of_DNA_evolution>

I would run a few different models, starting with "raw". Definitely include "K80" (see below) and then pick 1-2 other models to run. Briefly explain why one model might be better than another (hint: the example data are seasonal flu sequences). ?dist.dna() can be helpful

You can visualize the pairwise distances as a distance matrix. This isn't a super practical figure that you would include in most main manuscripts, but is useful for showing that the distance matrix exists and helps to show what a distance matrix is.

```{r}
# raw
```

```{r}
# Kimura, 1980
dist <- dist.dna(s, model = "K80")
```

# Methods of Phylogenetic Tree Construction

## Construct phylogenetic tree and create tree object

Here, four different methods are shown to construct a phylogenetic tree with a distance matrix as the input. First is the original neighbor-join method. This method essentially works to find pairs, or neighbors, that minimize the total branch length at each stage of clustering. The resulting tree is then plotted.

```{r}
# Neighbor-Joining
t1 <- nj(dist)
ggtree(t1) +
  geom_tiplab(size=2) + options(ignore.negative.edge = TRUE)
```

Next is an updated version of the previous method. This method minimizes the variances associated with each distance estimate being made. It is essentially a Minimum Variance Reduction Method, but it does not account for covariance.

```{r}
# Neighbor-Joining 2.0
t2 <- bionj(dist)
ggtree(t2) +
  geom_tiplab(size=2) 
```

Nest we have a minimum evolution approach that is essentially and neighbor join method used in conjunction with ordinary least-squares (OLS), which searches for the best topology using nearest neighbor interchanges.

```{r}
# Minimum Evolution OLS
t3 <- fastme.ols(dist)
ggtree(t3) +
  geom_tiplab(size=2)
```

Lastly, here is a similar approach as the previous, but this uses a balanced minimum evolution scheme, which is weighted so that sibling subtrees have equal weight.

```{r}
#Minimum Evolution BAL
t4 <- fastme.bal(dist)
ggtree(t4) +
  geom_tiplab(size=2)
```

# Phylogenetic Tree Visualization

## Plot/visualize tree using ggtree

```{r}
# open tree in new window for optimal viewing
ggtree(t1) +
  geom_tiplab()
```

## Add metadata to the tree

```{r}
p <- ggtree(t1) %<+% d
```

## Annotate tree tip labels using color

### Color by year

```{r}
library(viridis)
p + geom_tiplab(aes(color = year), size = 3) +
    scale_color_viridis_c() +
    theme_tree2()
```

### Color by state

```{r}
p + geom_tiplab(aes(color = state), size = 3) +
    scale_color_hue(n = 15) +
    theme_tree2()
```

## Annotation using US state flags

A color scale for 15 states isn't very intuitive for the viewer to comprehend, so the function **us_state_flag_tree()** annotates each tip label based on the state a flu strain sequence is from.

First, we need to add the path to the state flag icons to the metadata using the custom **to_image()** function.

```{r}
d <- to_image(d)
```

Now we can use **us_state_flag_tree()** to create a tree where the tip labels are annotated with US state flags.

```{r}
us_state_flag_tree(tree = t1, metadata = d, image_column = "ImagePath", label_column = "accession")
```
