---
title: "phylo101 Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{phylo101 Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# phylo101: Introduction to Phylogenetics

## Load required packages

```{r setup}
library(adegenet)
library(ape)
library(ggtree)
library(ggimage)
library(readr)
library(phylo101)
library(dplyr)
```

## Check that metadata is loaded

```{r}
d <- USFluMetadata
print(d)
```

## Check that sequences are loaded

```{r}
s <- USFluSeqs
print(s)
```

# Models of DNA Evolution

## Calculate pairwise distances

Wikipedia entry about models: <https://en.wikipedia.org/wiki/Models_of_DNA_evolution>

We run a few different models, starting with "raw". Definitely include "K80" (see below) and then pick 1-2 other models to run. 

We can visualize the pairwise distances as a distance matrix. This isn't a super practical figure that you would include in most main manuscripts, but is useful for showing that the distance matrix exists and helps to show what a distance matrix is.


```{r}
# raw
#when sequences so different, evolutionary distant species
dist0<-dist.dna(s,model = "raw")

#as.matrix(dist0)
#very long matrix
```

The Kimure 1980 model is the best for seasonal flu sequences; Because flu evolves quickly
with high transition/transversion bias - and K80 model considers those different rates - reflecting real mutation patterns

```{r}
# Kimura, 1980

dist <- dist.dna(s, model = "K80")
#as.matrix(dist)
```

JC69 assumes equal base frequencies and substitution rates.
Felsenstein (1981) generalized the JC model by relaxing the assumption of equal base frequencies.

```{r}
#Jukes and Cantor 1969
dist1<-dist.dna(s,model = "JC69")
#as.matrix(dist1)

# Felsenstein (1981)
dist2<-dist.dna(s,model = "F81")

 
#finding largest difference between matrixes 
 
#Decided to compare the differences is matrixes
#here comparing to matrix and extracting the higest difference value

d1 <- max(abs(as.matrix(dist0) - as.matrix(dist1)))
d2 <- max(abs(as.matrix(dist0) - as.matrix(dist)))
d3 <- max(abs(as.matrix(dist0) - as.matrix(dist2)))
d4 <- max(abs(as.matrix(dist1) - as.matrix(dist)))
d5 <- max(abs(as.matrix(dist) - as.matrix(dist2)))


 
# Make a data frame
 
# Making a data frame to visualize as a table
comparison_table <- data.frame(
  Comparison = c("dist0 vs dist1 (raw vs JC69)",
                 "dist0 vs dist (raw vs K80)",
                 "dist0 vs dist2 (raw vs F81)",
                 "dist1 vs dist (JC69 vs K80)",
                 "dist vs dist2 (K80 vs F81)"),
  Max_Abs_Difference = c(d1, d2, d3, d4, d5)
)

comparison_table

```

# Methods of Phylogenetic Tree Construction

## Construct phylogenetic tree and create tree object

Construct trees using one of the distance matrices created above, preferably the "best" one (if available). Then run a few methods of constructing the phylogeny. I've provided some suggestions- but feel free to use different methods. After each model I would create a basic tree visualization (using ggtree makes the most sense here).

```{r}
# Neighbor-Joining 2.0
t1 <- bionj(dist)

#contructing tree to another model matrix
t_jc <-bionj(dist1)
```
 
Here, four different methods are shown to construct a phylogenetic tree with a distance matrix as the input. First is the original neighbor-join method. This method essentially works to find pairs, or neighbors, that minimize the total branch length at each stage of clustering. The resulting tree is then plotted.
 
```{r}
# Neighbor-Joining
t1 <- nj(dist)
ggtree(t1) +
  geom_tiplab(size=2) + options(ignore.negative.edge = TRUE)
```

Next is an updated version of the previous method. This method minimizes the variances associated with each distance estimate being made. It is essentially a Minimum Variance Reduction Method, but it does not account for covariance.

```{r}
# Neighbor-Joining 2.0
t2 <- bionj(dist)
ggtree(t2) +
  geom_tiplab(size=2) 
```

Nest we have a minimum evolution approach that is essentially and neighbor join method used in conjunction with ordinary least-squares (OLS), which searches for the best topology using nearest neighbor interchanges.

```{r}
# Minimum Evolution OLS
t3 <- fastme.ols(dist)
ggtree(t3) +
  geom_tiplab(size=2)
```

Lastly, here is a similar approach as the previous, but this uses a balanced minimum evolution scheme, which is weighted so that sibling subtrees have equal weight.

```{r}
#Minimum Evolution BAL
t4 <- fastme.bal(dist)
ggtree(t4) +
  geom_tiplab(size=2)
```

# Phylogenetic Tree Visualization

## Plot/visualize tree using ggtree

```{r}
# open tree in new window for optimal viewing
ggtree(t1) +
  geom_tiplab()
```

## Add metadata to the tree

```{r}
p <- ggtree(t1) %<+% d
```

## Annotate tree tip labels using color

### Color by year

```{r}
library(viridis)
p + geom_tiplab(aes(color = year), size = 3) +
    scale_color_viridis_c() +
    theme_tree2()
```

### Color by state

```{r}
p + geom_tiplab(aes(color = state), size = 3) +
    scale_color_hue(n = 15) +
    theme_tree2()
```


## Annotation using US state flags

A color scale for 15 states isn't very intuitive for the viewer to comprehend, so the function 
**us_state_flag_tree()** annotates each tip label based on the state a flu strain sequence is from.

First, we need to add the path to the state flag icons to the metadata using the custom **to_image()** function.

```{r}
d <- to_image(d)
```

Now we can use **us_state_flag_tree()** to create a tree where the tip labels are annotated with US state flags.

```{r}
#us_state_flag_tree(tree = t1, metadata = d, image_column = "ImagePath", label_column = "accession")
```

## For comparison here building another phylogenetic tree from different matrix model JC69
The both tree is identical, since there is no significant differences in genetic distances using different models;
```{r}
#another model tree construction
p2 <- ggtree(t_jc) %<+% d

library(viridis)
p2 + geom_tiplab(aes(color = year), size = 3) +
    scale_color_viridis_c() +
    theme_tree2()

#us_state_flag_tree(tree = t_jc, metadata = d, image_column = "ImagePath", label_column = "accession")
```
